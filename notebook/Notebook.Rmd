---
title: "R 笔记"
# author: "gly"
# date: "3/4/2022"
output: 
  html_document:
    toc: true

---

***
# 
***2022-3-4***

## R 工作路径设置


### 查看工作路径：
```{r, tidy=TRUE, eval=FALSE}
getwd()
```
### 设置工作路径：
#### 1. 使用代码
example:
```{r, tidy=TRUE, eval=FALSE}
setwd("~/bin/R/project1")       # RGui & RStudio皆可使用
```


#### 2. RStudio中创建项目：
File -- New Project -- Existing Directory，选择路径即可。

## 安装包及调用包

### 图形界面
在Packages中搜索选择所需的包（RGui & RStudio皆可）。

### 命令行
通过
```{r, tidy=TRUE, eval=FALSE}
install.packages("pkg_name")    # pkg_name为包的名字，双引号为必需
install.packages(c("package1", "package2"))   # 安装多个包
```
命令

### 使用包
使用
```{r, tidy=TRUE, eval=FALSE}
library("pkg_name")       # 双引号非必需
```
将包加载到当前R会话中，在当前R会话关闭前都可使用。

使用
```{r, tidy=TRUE, eval=FALSE}
library()
```
查看当前R库中存储的包。

#### 注[^1]：
另外可通过
```{r, tidy=TRUE, eval=FALSE}
install_github(...)
install_bitbucket(...)
```
安装未托管至CRAN的包

[^1]: 参考《R语言入门与实践》附录B。

## 求助
控制台中使用
```{r, tidy=TRUE, eval=FALSE}
?func_name
```
或者
```{r, tidy=TRUE, eval=FALSE}
help(func_name)
```
获得帮助

## R Markdown
* 先安包;

```{}
### 记录一次安装rmarkdown
当我尝试在Ubuntu中安装rmarkdown时，总是失败，阅读错误信息发现是`stingi`安装失败，原因为在安装时尝试从github上下载ICU data library，然而由于众所周知的原因超时失败，于是导致无法安装。
查阅R Documentation，发现一条：`SystemRequirements:	C++11, ICU4C (>= 55, optional)`，说明`ICU`依赖属于系统层面的依赖，查询发现应安装`libicu-dev`包，因此使用`apt install libicu-dev`安装，而后安装`stringi`成功
```

* 拓展名：.Rmd；

* 可支持编译为：.html, .pdf及Word文件。

  * ***注***：pdf及word格式输出需要相应的支持，如：***Tex Live, MS Word, Libre/Open Office***等。

\n
* 基本语法与***markdown***基本相同，支持*tex*格式的公式编辑；

### 插入代码块

* 插入代码块（多行或单行代码）：
````{}
```{r, tidy=TRUE, eval=FALSE}     # {}中为设置，输入R，则该代码块将会被当成R语言代码执行，其后为命名，','后为设置，如‘echo=FALSE’（不打印代码），'tidy=TRUE'（自动优化排版）, 'eval=FALSE'（不执行）；留空则不执行;
# code 
```
````
  &emsp;插入代码（该段使用多层嵌套，故可在输出代码块中显示 \```，否则将自动识别为代码块语法而进行渲染）
  
  &emsp;或者行前两个tab（注意该行前需空一行），可实现单行代码：
  
    # 这是一个单行代码


### 插入注释

  * 可用markdown语法：
```{md}
[ ]: comment 
```
  &emsp; 进行注释，其中[ ]内可加任何东西，可组成表情包注释。

[-_-]: 这是一条注释

  * 也可使用html注释：
```{html}
<!--也是注释-->

<!--
多
行
注
释
-->
```
<!-- 注释 -->

<!-- 
注释
-->


***


# 

***2022-3-11***

## R语言基础 I

### 数据类型
R的基本数据类型包括：

* **数值型**(numeric)：包括整型数值、浮点型数值
* **逻辑型**(logical)：包括Ture、False 
* **字符型**(character)：包括单引号或双引号括起来的字符序列

R数据类型转换：

* 当数值型、逻辑型、字符型同时出现在同一向量中时，数据类型会按照逻辑型、数值型、字符型的顺序进行转换。
即：

  * 逻辑型和数值型同时出现在向量或矩阵中时，逻辑型数据转换为数值型，TRUE转换为1，FALSE转换为0；

  * 逻辑型、数值型、字符型同时出现在向量或矩阵中时，全部转换为字符型。


### 常量变量
R中的常量指：其值不能改变的量，包括：

* **数值常量**(numeric constant)：包括所有**整型**(integer)、**浮点型**(float)、**复数型数据**(complex)；
* **字符常量**(character constant)：包括所有的**字符型**数据；
* **逻辑常量**(logical constant)：包括`TRUE`和`FALSE`两个逻辑型数据

R变量用于存储R对象。变量有变量名，亦称**变量标识符**(identifier)

* 变量名必须由*字母、数字、下划线和句点（.）*组成，且第一个字符不能是数字；若第一个字符是句点，第二个字符必须是字母；
* 中文环境下，汉字可作为合法变量名；
* 变量名区分大小写

### 保留字
R中，具有特定含义，不能用作变量标识符的单词， 称为保留字，主要包括：

* 函数定义及程序控制保留字： `function`, `if`, `else`, `for`, `while`, `repeat`, `break`, `continue`, `next`；
* 逻辑常量保留字： `TRUE`, `FALSE`；
* `Inf`：正无穷，比如1/0；
* `NaN`（Not a Number）：数学上不存在的数，比如0/0，两个正无穷相减；
* `NA`（Not Available）：尚未得到的数据，也称为缺失数据；
* `NULL`：空值对象。

## R语言基础II：数据结构
学习数据结构要关注两个方面：
一是***数据结构定义***； 二是***数据结构元素访问形式***。

综述：

* **向量**是R最基础的、 *“原子型”(atomic)*数据结构， “原子型”是指向量中各元素
*必须为相同类型数据*。

* R矩阵和数据框均为*二维“表格型”*数据结构，区别在于**矩阵元素**必须为或强制转化为*相同数据类型*，而**数据框**的各列可以是*包含不同数据类型的向量*。
数据框是R统计模型分析的基础。

* **列表**是R*最灵活*的数据结构，*可理解为“非原子型”向量*，列表的各个元素可
以是*向量、矩阵、数据框、 列表*。

### 向量(factor)
R中向量定义有两类方法。

* 一是通过基础通用的`c()`函数(c: concatenate，拼接)定义向量。
  * 基本语法为： 
```{r, tidy=TRUE, eval=FALSE}
  c(…)
```
  其中`...`表示可变长度输入参数，拟拼接到一起的数据对象，用英文输入逗号分隔。
  * 向量访问格式为：向量名[拟访问元素索引向量]。

* 二是有规律向量的快捷定义。 针对有规律向量，比如等差数列、格式有规律的字符串序列， R提供了更简洁的定义方式。主要涉及到R自带的
`seq()`, `rep()`, `paste()`, `numeric()`, `character()`函数

### 矩阵(matrix)
R中矩阵由函数matrix()定义：

```{r, tidy=TRUE, eval=FALSE}
matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL)
```

* `data`：数据向量，默认值为缺失值NA,

* `nrow`：行数，默认值为1；

* `ncol`：列数，默认值为1；

* `byrow`：逻辑型，表示数据向量是否按行排列成矩阵，默认FALSE,即：默认按列填充；

* `dimnames`：矩阵行列名，默认为空值，或者为长度为2的列表，列表元素分别为字符型向量，表示行列名。

矩阵元素/子矩阵访问格式为： `mat_name[row_index（行索引）, col_index（列索引）]`。

**注：**

* `letters`与`LETTERS`为R内置向量，分别表示26位小写和大写拉丁字母。
* `list()`函数为列表定义函数，后文将介绍。

### 数据框(data frame)

R中数据框由函数`data.frame()`定义：

```{r, tidy=TRUE, eval=FALSE}
data.frame(..., row_names = NULL, stringsAsFactors = TRUE)
```

其中：

* `...`：可变长度输入参数，格式为value，或者tag=value；

* `row_names`：行名，默认为空；

* `stringsAsFactors`：字符型向量是否当作*因子*处理，默认为`TRUE`；

数据框的索引和矩阵类似： `data.frame_name[row_index,col_index]`

其中：`row_index`、`col_index`可以替换为数据框行列。
也可通过如下形式访问数据框元素：

* `data.frame_name$col_name`，返回*列对应向量*；

* `data.frame_name[[col_name]]`，返回*列对应向量*；

* `data.frame_name[col_name]`，返回*特定列对应子数据框*。

不同索引方式的区别：

```
d[[“age”]]        # 返回age向量
d[“age”]          # 返回只包含一个age字段的子数据框；
```

两种索引中，变量名`age`要用一对双引号括住；

而使用`$col_name`访问时可以不要双引号;

采用双下标索引形式时，如果包含全部行或全部列，对应索引可以省略。


**注：**

* 因子为R中特殊的数据类型

* 向量和数据框在R控制台中的显示形式不一样，我们可以通过显示形式来倒推其类型

### 列表(list)

R中列表通过list()函数定义，基本语法为：

```{r, tidy=TRUE, eval=FALSE}
list(…)
```

列表元素访问有两种格式：

* 一是`list.name[index]`，此时返回子列表；
* 二是`list.name[[single_index]]`，此时返回单个索引指标对应的数值或数据结构。

**注：**

* 若在定义列表时，给列表中的元素取了名字，则可使用该名字对列表进行访问。

### 因子(factor)

* **因子**是*向量型对象(vector object)*
* R中用因子代表数据中分类变量,如性别、省份、职业
* R提供了*无序因子(unordered factors)*和*有序因子(ordered factors)*
* 有序因子代表有序量度，如打分结果，疾病严重程度等。
* 因子的创建通过`factor()`函数实现，其语法如下:
```{r, tidy=TRUE, eval=FALSE}
factor(x = character(), levels, labels = levels,
        exclude = NA, ordered = is.ordered(x), nmax = NA)
```

其中：

* `x`:数据向量，通常仅取少数几个不同值
* `levels`:可选字符型向量,默认为x不同取值从小到大排序并转换成字符型
* `labels`:用于表达各水平值的*标签*
* `exclude`:构造因子水平时拟剔除水平值
* `ordered`:*逻辑标志(logical flag)*，声明水平是否有序
* `nmax`:最大因子水平数

***

# 

*** 2022-3-18***

## R运算符和控制结构

### R运算符

R运算符主要包括：*算术运算符、关系运算符、逻辑运算符*

* R逻辑运算符：
  * `!`: 逻辑非(logical NOT)
  * `&`: 逐个元素逻辑与(element-wise logical AND)
  * `|`:逐个元素逻辑或(element-wise logical OR)
  * `&&`: 首元素逻辑与(first element logical AND) 
  * `||`: 首元素逻辑或(first element logical OR)
  * 逻辑运算的自变量只能为数值型或逻辑型变量。
* **注**：
  * 除了逻辑非（`!`）运算符，其他所有运算符都可认为是*二元函数*（本质上是二元函数）。
  * 运算符函数的自变量可取值*向量、矩阵*等。
  * 除了首元素逻辑与（`&&`）和首元素逻辑或（`||`），当参与运算的两个变量均为向量或矩阵是，R按***对应位置***（`element-wise`）执行相应的运算，结果仍为*相同维度*的向量或矩阵。
  * 在R中，数值0为`FALSE`，非0数值为`TRUE`

* R算术运算符
  * `+`：加(addition)
  * `-`：减(subtraction)
  * `*`：乘(multiplication)
  * `/`：除(division)
  * `^`：乘方(exponentiation)
  * `%%`：求余(modulus=remainder from division)
  * `%/%`：整除(integer division)
  * 算数运算的自变量主要为数值型

* R关系运算符
  * `<`: 小于(less than)
  * `>`: 大于(greater than)
  * `<=`: 小于等于(less than or equal to)   
  * `>=`: 大于等于(greater than or equal to) 
  * `==`: 等于(equal to)
  * `!=`: 不等于(not equal to)
  * 关系运算的自变量只能为*数值型或逻辑型*。

* R的运算符优先级及结合律
  * 算术运算>关系运算>逻辑运算
  * 乘方>乘除>加减
  * 相同优先级运算符，由左至右依次两两结合计算。
  * 可通过一对圆括弧()改变运算符计算次序。
  * 相同运算符在一个表达式中可能连续出现多次， 此时由运算符的*结合律*决定表达式取值。
  * 除了*“乘方”*运算符和*向左赋值*运算符，结合律规则为*“由右向左”*，其它主要运算符结合顺序为*“由左向右”*。

### R条件语句

* 单条件语句：

```{r, tidy=TRUE, eval=FALSE}
if( condition ){
  # code
}
```
* 复合条件语句:

```{r, tidy=TRUE, eval=FALSE}
if( condition ){
  # code
} else {
  # code
}

```

* 多条件语句

```{r, tidy=TRUE, eval=FALSE}
if( condition_1 ){
  # code
} else if( condition_2) {
  # code
}
···
else if ( condition_n ) {
  # code
} else {
  # code
}
```

### R循环语句

* `for`循环：
  * 通过向量控制循环，并称该向量为**循环向量**
  * （类似Python中的`for i in range(x): ···`）
```{r, tidy=TRUE, eval=FALSE}
for (i in v) {
  # code
}
```

* `while`循环
  * 通过条件表达式控制循环是否执行
```{r, tidy=TRUE, eval=FALSE}
while ( condition ) {
  # code
}
```

***

# 

***2022-3-25***

## 函数

* **函数**是执行特定任务的代码封装。
* R中有两类函数
  * 一是各种包自带函数
  * 二是用户自定义函数
* 函数的特点：
  * 可以接收*参数(arguments,parameters)*，也可以不接收;
  * 可以返回*值*(通常为一个数据结构，比如列表)，也可以 不返回;
  * 可以有*函数名*，也可以没有函数名，后者称为**匿名函数**。
* 使用用户自定义函数，
  * 可以通过控制台`source()`函数(比如`source(“~/bin/r/rbin/myFun.r”)`，把保存特定函数的R脚本文件绑定到当前R会话(R session)
  * 或者直接把函数定义拷贝到R控制台。
  
### 函数定义

函数定义的结构为：

```{r, tidy=TRUE, eval=FALSE}
fun_name <- function( args_list ) {
  # code
  # return(expression)    # 可以没有 
}
```

其中：

  * `fun_name`：函数名
  * `args_list`：参数列表，可以用等号设置默认值，则无参数调用时使用默认值
  * `# code`：函数代码
  * `# return(expression)`：函数返回值（可以不返回，则没有）
  
另外有**可变参数函数**
  * 在形参列表中使用`...`
  * 例如：
```{r, tidy=TRUE}
# 函数定义举例
powers <- function(x, ...) {
  for(i in list(...)) { 
    print(x^i)
  } 
}

# 注意调用返回结果的不同 
powers(2, 1,2,3,4,5,6)
powers(2, 1:6)
powers(2, matrix(1:6,2), 1:6, 1,2,3,4,5,6)
```

另外，匿名函数可定义如下：
```{r, tidy=TRUE}
# 定义一个匿名函数并执行
(function(x, y=c(1,2,3)){ return(x^y)})(3)
```

### 函数的调用

* 函数调用的方式有：
  * *按（形参）位置*调用
  * *按关键字（形参名）*调用
  * *混合调用*
* 函数调用时，实参和形参的类型有时不同，如：

```{r, tidy=TRUE}
fun <- function(x, y=c(1, 2, 3)) {
  return(x^y)
}

fun(3)
fun(y=3, x=2)
fun(y=3, 2)

fun(3, 1:6)
fun(2, matrix(1:6, nrow=2))
```

### 关于 '`...`'[^2]

[^2]: 见：https://cran.r-project.org/doc/manuals/r-release/R-intro.html

> #### 10.4 The ‘`...`’ argument<br>
Another frequent requirement is to allow one function to pass on argument settings to another. For example many graphics functions use the function `par()` and functions like plot() allow the user to pass on graphical parameters to `par()` to control the graphical output. (See Permanent changes: The `par()` function, for more details on the `par()` function.) This can be done by including an extra argument, literally ‘`...`’, of the function, which may then be passed on. An outline example is given below.<br>
```{r, eval=FALSE}
fun1 <- function(data, data.frame, graph=TRUE, limit=20, ...) {
  [omitted statements]
  if (graph)
    par(pch="*", ...)
  [more omissions]
}
```

> Less frequently, a function will need to refer to components of ‘`...`’. The expression `list(...)` evaluates all such arguments and returns them in a named list, while ..1, ..2, etc. evaluate them one at a time, with ‘..n’ returning the n’th unmatched argument.

> #### 12.4.1 Permanent changes: The `par()` function<br>
The `par()` function is used to access and modify the list of graphics parameters for the current graphics device.

```{r, eval=FALSE}
`par()`
> Without arguments, returns a list of all graphics parameters and their values for the current device.

par(c("col", "lty"))
> With a character vector argument, returns only the named graphics parameters (again, as a list.)

par(col=4, lty=2)
> With named arguments (or a single list argument), sets the values of the named graphics parameters, and returns the original values of the parameters as a list.
```

> Setting graphics parameters with the `par()` function changes the value of the parameters permanently, in the sense that all future calls to graphics functions (on the current device) will be affected by the new value. You can think of setting graphics parameters in this way as setting “default” values for the parameters, which will be used by all graphics functions unless an alternative value is given.<br>
Note that calls to `par()` always affect the global values of graphics parameters, even when `par()` is called from within a function. This is often undesirable behavior—usually we want to set some graphics parameters, do some plotting, and then restore the original values so as not to affect the user’s R session. You can restore the initial values by saving the result of `par()` when making changes, and restoring the initial values when plotting is complete.

```{r, eval=FALSE}
  > oldpar <- par(col=4, lty=2)
    … plotting commands …
  > par(oldpar)
  
To save and restore all settable25 graphical parameters use

> oldpar <- par(no.readonly=TRUE)
  … plotting commands …
> par(oldpar)
```

***

#

***2022-4-1***

## R基本概率分布（随机变量相关函数及R实现）

### R基本随机变量相关函数（5种）

R提供了专门函数，用于计算随机变量，如：

* *二项(binomial)*分布
* *泊松(poisson)*分布
* *超几何(hypergeometric)*分布
* *正态(normal)*分布
* *均匀(uniform)*分布

对应的：

* *密度(density)*函数
* *分布(probability)*函数
* *分位数(quantile)*函数在特定自变量处的取值
* 从特定分布产生*随机数(random number)*， 比如用于*蒙特卡洛计算*

* 函数的共同点：
  * 函数名由*函数类型英文首字母*+*随机变量英文缩写*构成。
  比如二项分布的概率函数名为`pbinom`，正态分布的密度函数名为`dnorm`。
* 函数的不同点：不同分布对应函数的参变量形参名不同。比如
  * 二项分布的伯努利试验次数和成功概率两个形参名分别为`size`和`prob`；
  * 正态分布的均值和标准差形参名分别为m`ean`和`sd`；
  * 均匀分布区间端点对应形参名分别为`min`和`max`。
  
**注：**

* 使用“形参=实参值”格式调用这些函数时，要特别注意不同分布对应的形参名。
* 超几何分布对应R函数中，形参m,n,k的含义与教科书和一般参考资料中不一致，使用时要小心。
* R中各个分布的函数名命名规则比较有规律，但
不同分布的形参名容易混淆。相关函数调用，
尤其是通过“形参名=实参值”形式调用时，要正确使用形参名。

## 蒙特卡洛方法（的应用）

### 定积分的蒙特卡洛近似计算

定积分蒙特卡洛近似计算的基本思想

* 一方面， 有界区间上的定积分(有界区间不是必须的，区间无界时，可用正态随机变量替代均匀随机变量)，只要积分存在，总可以理解为均匀分布随机变量某函数变换的数学期望，比如：

$$
\begin{aligned}
&\int_{a}^{b} g(x) d x=\int_{a}^{b} g(x)(b-a)  \times \frac{1}{b-a} d x \\
&=\int_{a}^{b} h(x) p_{U(a, b)}(x) d x=E_{U(a, b)}\{h(X)\}
\end{aligned}\\
( g(x) \triangleq h(x);\\
\frac{1}{b-a} \triangleq p_{U(a, b)} ;)
$$

* 另一方面，由大数定律，若$𝑋_𝑖$为$𝑈(𝑎, 𝑏)$独立重复观测序列（为了与代码一致、并与样本量区分，重复次数记为${mc.rep}$），则重复次数${mc.rep}$充分大时，

$$
\frac{1}{\text { mc.rep }} \sum_{i=1}^{\text {mc.rep }} h\left(X_{i}\right) \approx E_{U(a, b)}\{h(X)\}=\int_{a}^{b} g(x) d x
$$

* 因此，可以通过产生一定量的随机数、计算各自函数值、求算术平均的方法，近似计算定积分。这种方法称为**定积分的蒙特卡洛近似计算**。

#### 例1：定积分有精确值

$$
g(x) = x\\
\int_{0}^{2} g(x) dx = ?
$$

```{r}
a = 0
b = 2
g = function(x)x

set.seed(1)     # 固定随机数生成初值，确保结果可重复计算
mc.rep = 100    # 蒙特卡洛重复观测次数

integ = function(a, b, r) {
  mean( (b-a)*g(runif(mc.rep, min=a, max = b)) )
}

integ(a, b, mc.rep)

mc.rep = 10000  # 重设观测次数
integ(a, b, mc.rep)

integrate(g, lower = a, upper = b)
```

#### 例2：定积分无精确值

$$
g(x) = dnorm(x) \\
\int_{-2}^2 g(x)dx=? \\
(dnorm(x, \mu, \sigma) = \frac{1}{\sqrt{2 \pi } \sigma } e^{-\frac{(x - \mu)^2} {2 \sigma^2}};\\
dnorm(x) = dnorm(x, 0, 1))
$$

```{r}
a = -2
b = 2
g = function(x) dnorm(x)

set.seed(1)     # 固定随机数生成初值，确保结果可重复计算
mc.rep = 100    # 蒙特卡洛重复观测次数

integ = function(a, b, r) {
  mean( (b-a)*g(runif(mc.rep, min=a, max = b)) )
}

integ(a, b, mc.rep)

mc.rep = 10000        # 重设观测次数
integ(a, b, mc.rep)

integrate(g, lower = a, upper = b)

pnorm(b) - pnorm(a)   # 正态函数pnorm()法
```

另外，此题可用标准正态分布的随机数来解答：

$$
\text{定义}\\
I_{(-2, 2)} = 
\left\{\begin{matrix} 
  1，x \in (-2, 2)\\  
  0, 否则
\end{matrix}\right.
$$

有数学期望的性质知：

$$
E(I_{(-2, 2)} (X) ) = \int_{-2}^{2} \varphi(x)dx，
$$

再由大数定律知：

$$
P(-2<X<2) \approx \frac{1}{n} \sum_{k=1}^{n} I_{(-2,2)}\left(X_{k}\right)
$$

其中，$X_i(i=1, 2, 3, ···, n)$为标准正态分布随机数。可用如下R代码完成近似：

```{r}
x = rnorm(mc.rep, 0, 1)
I = x>-2 & x<2
p = mean(I)
p
```

### 中心极限定理的有限样本表现

中心极限定理简介

* 在统计分析实践中，通常需要掌握样本均值$\bar{X}_{n}$的分布函数（通常精确分布函数非常复杂）。中心极限定理告诉我们，只要总体方差有限，样本均值的标准化变量${Z}_{n}$作为样本均值变量的线性变换，其分布函数在任何一点的取值，随着样本量𝑛的增加，收敛到标准正态分布在相同点取值；其中

$$
Z_{n}=\frac{\bar{X}_{n}-E\left(\bar{X}_{n}\right)}{s d\left(\bar{X}_{n}\right)}=\frac{\sqrt{n}\left\{\bar{X}_{n}-E(X)\right\}}{\sqrt{D(X)}}
$$

问题是：*$n$大到什么程度*，可以使用正态分布函数近似${Z}_{n}$的精确分布函数？

* 可综合使用蒙特卡洛方法、**经验分布计算函数**`ecdf()`、**基础绘图函数**`plot()`，以及`lines()`函数，考察不同样本量下，${Z}_{n}$精确分布函数${P}({Z}_{n}≤{z})$的蒙特卡洛近似与标准正态分布函数$\Phi({z})$，*在任一点${z}$的接近程度*。

#### 例：

```{r}
# 总体为泊松分布 P(0.5)
lamda = 0.5

# 蒙特卡洛重复次数为100000
mc.rep = 100000

# 拟考察的样本量为10，30，50，100
# 拟在一下点处计算分布函数取值
z = seq(-3, 3, 0.1)

# 绘图窗口
par(mfrow = c(2, 2))
for (n in c(10, 30, 50, 100)) {
  
  # 通过抽取泊松分布随机函数获得Zn的100000次重复观测
  x = matrix(rpois(n*mc.rep, lambda = lamda), nrow = n)
  
  # 获取特定样本量下 Zn 的 mc.rep 次重复值
  Zn = sqrt(n)*(colMeans(x) - lamda) / sqrt(lamda)
  
  # 计算Zn的mc.rep次重复值对应的经验分布函数（因mc.rep很大，可以视为Zn的精确分布）并绘图
  plot(ecdf(Zn), xlab = "z", ylab = "分布函数值", main = paste("样本量n=", n, sep=""), family = "STXihei")
  
  # 添加标准正态分布函数，以便同Zn精确分布（的蒙特卡洛）作比较
  lines(z, pnorm(z), col = "red", lty = 2)
}
```
